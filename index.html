<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Yoursound</title>
    <script src="p5.min.js"></script>
    <script src="p5.sound.min.js"></script>
</head>
<body>
    <script>
        // 5つのオシレーター管理（配列化）
        const osc = [null, null, null, null, null, null];           // index 0は使わない
        const started = [false, false, false, false, false, false];  // started[1-5]
        const isSounding = [false, false, false, false, false, false];
        const playingCount = [0, 0, 0, 0, 0, 0];
        const stopTimeout = [null, null, null, null, null, null];
        
        // 周波数管理（配列化）
        const freq = [0, 220, 330, 330, 330, 330];     // freq[1]=220固定, freq[2-5]=可変
        const savedFreq = [0, 0, 330, 330, 330, 0];    // savedFreq[2-4]=保存周波数

        // フェーズ管理
        let phase = 1; // 1: OSC1+OSC2, 2: OSC2+OSC3, 3: OSC3+OSC4, 4: OSC4+OSC5

        // フェーズ遷移アニメーション中フラグ
        let isPhaseTransitionAnimating = false;

        // フェーズ遷移アニメーションの継続時間（ミリ秒）
        const phaseTransitionAnimDuration = 800; // 例: 800ms

        // クリック追跡
        let isDraggingSlider = false; // メーター境界ドラッグ状態

        // 色の配列（各OSCの色）
        const colors = {
            1: { light: [100, 150, 255], dark: [70, 100, 200] },      // 青
            2: { light: [255, 150, 100], dark: [255, 100, 50] },      // オレンジ
            3: { light: [150, 255, 150], dark: [100, 200, 100] },     // 緑
            4: { light: [200, 150, 255], dark: [150, 100, 200] },     // 紫
            5: { light: [255, 200, 150], dark: [200, 150, 100] }      // 黄色
        };

        // リズムタイミング（BPM 100）
        const BPM = 100;
        const beatDuration = (60 / BPM) * 1000; // 1拍のms
        let beatIndex = 0; // 0:osc1, 1:osc2, 2:both, 3:rest
        let lastBeatTime = 0;
        let isRunning = true; // オートプレイ実行フラグ
        let isMuted = false; // ミュート状態

        // 光の演出
        const glowIntensity = [0, 0, 0, 0, 0, 0];  // glowIntensity[1-5]
        const glowDecay = 0.05; // フレーム毎の減衰率
        
        // Phase 5用：周波数順のOSCインデックス配列
        let sortedOscIndices = [1, 2, 3, 4, 5]; // デフォルト
        
        // Phase 5用：メロディ配列（n番目に低い音を指定）
        // 1=最も低い音, 2=2番目に低い音, ..., 5=最も高い音
        const melodyPattern = [1, 2, 3, 4, 5, 4, 3, 2, 1, 3, 5, 2, 4, 5, 1];
        let melody = []; // melodyPattern から計算される実際のOSC番号配列

        const MAX_AMP = 0.25;
        const ATTACK = 0.05;  // 秒（アタック）
        const RELEASE = 0.3;  // 秒（リリース - 少し短く）

        function setup() {
            createCanvas(windowWidth, windowHeight);
            background(230);
            noStroke();

            // オシレーター初期化（ループで統一）
            for (let i = 1; i <= 5; i++) {
                osc[i] = new p5.Oscillator('sine');
                osc[i].freq(freq[i]);
                osc[i].amp(0);
            }

            // ユーザー操作でオーディオを初期化
            userStartAudio().then(() => {
                const ctx = getAudioContext();
                if (ctx && ctx.state !== 'running') ctx.resume();
                // オシレーターを start（まだ音は出ない - amp=0）
                for (let i = 1; i <= 5; i++) {
                    osc[i].start();
                    started[i] = true;
                }
            }).catch(e => console.log('userStartAudio error', e));

            savedFreq[1] = freq[1]; // OSC1は固定220Hz
        }

        // OSC周波数を保存してオクターブ処理を適用（440Hz超なら2分の1）
        function saveAndApplyOctave(oscIdx, nextOscIdx) {
            savedFreq[oscIdx] = freq[oscIdx];
            if (savedFreq[oscIdx] > 440) {
                savedFreq[oscIdx] = savedFreq[oscIdx] / 2;
                osc[oscIdx].freq(savedFreq[oscIdx]);
            }
            if (nextOscIdx) {
                freq[nextOscIdx] = savedFreq[oscIdx];
                osc[nextOscIdx].freq(freq[nextOscIdx]);
            }
        }

        function draw() {
            background(230);
            // デバッグ表示削除

            // ミュートボタン
            fill(isMuted ? 255 : 100);
            stroke(50);
            strokeWeight(2);
            rect(20, 20, 100, 40);
            fill(0);
            noStroke();
            textSize(14);
            textAlign(CENTER, CENTER);
            text(isMuted ? 'UNMUTE' : 'MUTE', 70, 40);

            if (phase === 5) {
                drawFinalUI();
            } else if (isPhaseTransitionAnimating) {
                // phase遷移アニメーション（phase1～4共通）
                let t = min(1, (millis() - phaseTransitionAnimStart) / phaseTransitionAnimDuration);
                let rectLW = 240;
                // 高さを補間（オクターブ処理時は変化、そうでなければ一定）
                let rectLH = lerp(phaseTransitionRectH0, phaseTransitionRectH1, t);
                let rectLY = height/2 + 300 - rectLH;
                let rectLX_from = width/2 + 80; // 右rectの位置
                let rectLX_to = width/2 - 320;  // 左rectの位置
                let rectLX = lerp(rectLX_from, rectLX_to, t);
                let oscIdx = phaseTransitionTo; // 新しい左rectのOSC番号
                let glowL = getGlowIntensity(oscIdx);
                let colorsL = colors[oscIdx];
                // グロー背景
                fill(colorsL.light[0], colorsL.light[1], colorsL.light[2], glowL * 150);
                stroke(colorsL.light[0], colorsL.light[1], colorsL.light[2], glowL * 200);
                strokeWeight(3 + glowL * 5);
                rect(rectLX - 5, rectLY - 5, rectLW + 10, rectLH + 10);
                // 本体
                fill(colorsL.dark[0], colorsL.dark[1], colorsL.dark[2], 140);
                noStroke();
                rect(rectLX, rectLY, rectLW, rectLH);
                // NOTEテキストのY座標を長方形の下辺-100に揃える
                let noteTextY = rectLY + rectLH - 100;
                fill(0);
                noStroke();
                textSize(20);
                textAlign(CENTER, CENTER);
                text('Note' + oscIdx, rectLX + rectLW/2, noteTextY);
                // OKボタン（真ん中下）
                let okButtonX = width/2 - 40;
                let okButtonY = height - 100;
                let okButtonW = 80;
                let okButtonH = 40;
                fill(150, 200, 150);
                stroke(50);
                strokeWeight(2);
                rect(okButtonX, okButtonY, okButtonW, okButtonH);
                fill(0);
                noStroke();
                textSize(16);
                textAlign(CENTER, CENTER);
                text('OK', width/2, okButtonY + okButtonH/2);
                if (t >= 1) {
                    // アニメ終了時に高さを保存
                    savedFreq[phaseTransitionTo] = phaseTransitionRectH1;
                    isPhaseTransitionAnimating = false;
                    phase = phaseTransitionTo;
                }
            } else if (phase === 1) {
                drawPhaseUI(1, 2);
            } else if (phase === 2) {
                drawPhaseUI(2, 3);
            } else if (phase === 3) {
                drawPhaseUI(3, 4);
            } else if (phase === 4) {
                drawPhaseUI(4, 5);
            }

        // phaseアニメ用UI

            // グロー強度を減衰させる
            for (let i = 1; i <= 5; i++) {
                glowIntensity[i] = max(0, glowIntensity[i] - glowDecay);
            }

            // リズムに合わせて音を再生
            updateAutoPlay();
        }

        function drawPhaseUI(leftOscIdx, rightOscIdx) {
            // 汎用フェーズ描画関数
            // leftOscIdx: 左の固定OSC番号
            // rightOscIdx: 右の可変OSC番号

            // 左側：固定OSC（phase1は220Hz固定、それ以外はsavedFreq）
            let rectLW = 240;
            let freqL = (leftOscIdx === 1) ? 220 : savedFreq[leftOscIdx];
            let rectLH = freqL;
            let rectLX = width/2 - 320;
            let rectLY = height/2 + 300 - rectLH;
            let glowL = getGlowIntensity(leftOscIdx);
            let colorsL = colors[leftOscIdx];
            // グロー背景
            fill(colorsL.light[0], colorsL.light[1], colorsL.light[2], glowL * 150);
            stroke(colorsL.light[0], colorsL.light[1], colorsL.light[2], glowL * 200);
            strokeWeight(3 + glowL * 5);
            rect(rectLX - 5, rectLY - 5, rectLW + 10, rectLH + 10);
            // 本体
            fill(colorsL.dark[0], colorsL.dark[1], colorsL.dark[2], 140);
            noStroke();
            rect(rectLX, rectLY, rectLW, rectLH);
            // テキスト（NOTE表記に変更、周波数・固定値は非表示）
            fill(0);
            noStroke();
            textSize(20);
            textAlign(CENTER, CENTER);
            // NOTEテキストのY座標を長方形の下辺-100に揃える
            let leftRectBottom = height/2 + 300;
            let noteTextY = leftRectBottom - 100;
            text('Note' + leftOscIdx, width/2 - 200, noteTextY);

            // 右側：可変OSC
            let rectRW = 240;
            let rectRX = width/2 + 80;
            let freqR = freq[rightOscIdx];
            let freqMin, freqMax, rectRH, rectRY;
            if (phase === 1) {
                // 0Hz～440Hz全体を表示。220Hz未満は常に濃い色、220Hz～440Hzは薄い/濃いで分割
                freqMin = 220;
                freqMax = 440;
                rectRH = 440; // 0～440Hz
                rectRY = height/2 + 300 - rectRH; // 上端
                let rect220Y = map(220, 0, 440, rectRY + rectRH, rectRY); // 220HzのY座標
                let meterBoundaryY = map(freqR, freqMin, freqMax, rect220Y, rectRY);
                meterBoundaryY = constrain(meterBoundaryY, rectRY, rect220Y);

                let glowR = getGlowIntensity(rightOscIdx);
                let colorsR = colors[rightOscIdx];

                // グロー背景（濃い色メーター部分に合わせる）
                fill(colorsR.light[0], colorsR.light[1], colorsR.light[2], glowR * 150);
                stroke(colorsR.light[0], colorsR.light[1], colorsR.light[2], glowR * 200);
                strokeWeight(3 + glowR * 5);
                rect(rectRX - 5, meterBoundaryY - 5, rectRW + 10, (rectRY + rectRH - meterBoundaryY) + 10);

                // 0Hz～現在値より下（濃い色）を1回で描画
                fill(colorsR.dark[0], colorsR.dark[1], colorsR.dark[2], 140);
                noStroke();
                rect(rectRX, meterBoundaryY, rectRW, rectRY + rectRH - meterBoundaryY);
                // 220Hz～現在値（薄い色）
                fill(colorsR.light[0], colorsR.light[1], colorsR.light[2], 60);
                rect(rectRX, rectRY, rectRW, meterBoundaryY - rectRY);
            } else {
                // Phase 2-4: 左OSCの保存周波数を基準
                let leftOscIdx = phase;
                freqMin = savedFreq[leftOscIdx];
                freqMax = savedFreq[leftOscIdx] * 2;
                rectRH = savedFreq[leftOscIdx] * 2;
                rectRY = height/2 + 300 - rectRH;
                // 中央Y座標
                let rectCenterY = rectRY + rectRH/2;
                // freqR→Y座標（中央～上端のみ可変）
                let meterBoundaryY = map(freqR, freqMin, freqMax, rectCenterY, rectRY);
                meterBoundaryY = constrain(meterBoundaryY, rectRY, rectCenterY);

                let glowR = getGlowIntensity(rightOscIdx);
                let colorsR = colors[rightOscIdx];

                // グロー背景（濃い色メーター部分に合わせる）
                fill(colorsR.light[0], colorsR.light[1], colorsR.light[2], glowR * 150);
                stroke(colorsR.light[0], colorsR.light[1], colorsR.light[2], glowR * 200);
                strokeWeight(3 + glowR * 5);
                rect(rectRX - 5, meterBoundaryY - 5, rectRW + 10, (rectRY + rectRH - meterBoundaryY) + 10);

                // 濃い色領域（中央～下端＋現在値～中央）を1回で描画
                fill(colorsR.dark[0], colorsR.dark[1], colorsR.dark[2], 140);
                noStroke();
                rect(rectRX, meterBoundaryY, rectRW, rectRY + rectRH - meterBoundaryY);

                // 中央～現在値（薄い色）
                fill(colorsR.light[0], colorsR.light[1], colorsR.light[2], 60);
                rect(rectRX, rectRY, rectRW, meterBoundaryY - rectRY);
            }
            
            fill(0);
            noStroke();
            textSize(20);
            textAlign(CENTER, CENTER);
            // NOTEテキストのY座標を長方形の下辺-100に揃える
            let rightRectBottom = height/2 + 300;
            let noteTextY2 = rightRectBottom - 100;
            text('Note' + rightOscIdx, width/2 + 200, noteTextY2);

            // OKボタン（真ん中下）
            let okButtonX = width/2 - 40;
            let okButtonY = height - 100;
            let okButtonW = 80;
            let okButtonH = 40;
            fill(150, 200, 150);
            stroke(50);
            strokeWeight(2);
            rect(okButtonX, okButtonY, okButtonW, okButtonH);
            fill(0);
            noStroke();
            textSize(16);
            textAlign(CENTER, CENTER);
            text('OK', width/2, okButtonY + okButtonH/2);
        }

        function drawFinalUI() {
            // Phase 5: 5つのOSCを周波数順（小さい順）に横並びで表示
            let rectW = 120; // 幅を大きく
            let spacing = 40; // 間隔も広く
            // 高さは保存した周波数に応じて個別に設定
            let oscData = [];
            for (let i = 1; i <= 5; i++) {
                let oscFreq = (i === 1) ? 220 : savedFreq[i];
                oscData.push({ idx: i, freq: oscFreq });
            }
            oscData.sort((a, b) => a.freq - b.freq);
            let maxH = Math.max(...oscData.map(d => d.freq));
            let totalW = rectW * 5 + spacing * 4;
            let startX = (width - totalW) / 2;
            let baseY = height/2 + 200; // 下端基準

            fill(0);
            noStroke();
            textSize(18);
            textAlign(CENTER, TOP);
            text('Complete!', width/2, 30);

            // ソート済みの5つのOSC長方形を描画
            for (let pos = 0; pos < 5; pos++) {
                let i = oscData[pos].idx;
                let oscFreq = oscData[pos].freq;
                let rectH = oscFreq; // 高さを周波数に応じて
                let x = startX + pos * (rectW + spacing);
                let y = baseY - rectH; // 下端揃え

                let glow = getGlowIntensity(i);
                let col = colors[i];

                // グロー背景
                fill(col.light[0], col.light[1], col.light[2], glow * 150);
                stroke(col.light[0], col.light[1], col.light[2], glow * 200);
                strokeWeight(3 + glow * 5);
                rect(x - 3, y - 3, rectW + 6, rectH + 6);

                // 本体
                fill(col.dark[0], col.dark[1], col.dark[2], 140);
                noStroke();
                rect(x, y, rectW, rectH);

                // テキスト（NOTE表記に変更、周波数は非表示）
                fill(0);
                noStroke();
                textSize(14);
                textAlign(CENTER, CENTER);
                // NOTEテキストのY座標を長方形の下辺-100に揃える
                let noteTextY = y + rectH - 100;
                text('Note' + i, x + rectW/2, noteTextY);
                // 周波数を220で割った値（小数第2位まで）をNOTEの下に表示
                let ratio = oscFreq / 220;
                let ratioText = ratio.toFixed(2);
                textSize(12);
                text(ratioText, x + rectW/2, noteTextY + 22);
            }
            // リセットボタン
            let resetButtonX = width/2 - 50;
            let resetButtonY = height - 100;
            let resetButtonW = 100;
            let resetButtonH = 40;
            fill(150, 150, 200);
            stroke(50);
            strokeWeight(2);
            rect(resetButtonX, resetButtonY, resetButtonW, resetButtonH);
            fill(0);
            noStroke();
            textSize(16);
            textAlign(CENTER, CENTER);
            text('RESET', width/2, resetButtonY + resetButtonH/2);
        }

        function getGlowIntensity(oscIdx) {
            return glowIntensity[oscIdx] || 0;
        }

        // *** CONSOLIDATED: Old drawPhase1-4 functions removed ***
        // All phase rendering is now handled by drawPhaseUI(leftOscIdx, rightOscIdx)



        function updateAutoPlay() {
            if (!isRunning || isMuted) return;
            // Phase 5の時はBPM 120、それ以外はBPM 100
            let currentBPM = (phase === 5) ? 120 : 100;
            let currentBeatDuration = (60 / currentBPM) * 1000; // 1拍のms
            let now = millis();
            if (now - lastBeatTime >= currentBeatDuration) {
                lastBeatTime = now;
                if (phase === 5) {
                    if (beatIndex >= melody.length) {
                        stopSound(melody[melody.length - 1]); // ★ これが重要
                        isRunning = false;
                        return;
                    }
                    // 前の音を止める
                    if (beatIndex > 0) {
                        stopSound(melody[beatIndex - 1]);
                    }
                    // 今の音を鳴らす
                    playSound(melody[beatIndex]);
                    beatIndex++;
                } else {
                    // フェーズ1～4: beatIndexに応じてOSCを鳴らす
                    // 0:左, 1:右, 2:両方, 3:休符
                    let leftOscIdx = phase;
                    let rightOscIdx = (phase === 1) ? 2 : phase + 1;
                    // 前の音を止める
                    stopSound(leftOscIdx);
                    stopSound(rightOscIdx);
                    if (beatIndex === 0) {
                        playSound(leftOscIdx);
                    } else if (beatIndex === 1) {
                        playSound(rightOscIdx);
                    } else if (beatIndex === 2) {
                        playSound(leftOscIdx);
                        playSound(rightOscIdx);
                    } // 3は休符
                    beatIndex = (beatIndex + 1) % 4;
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }

        function ensureAudioStarted() {
            return userStartAudio().then(() => {
                const ctx = getAudioContext();
                if (ctx && ctx.state !== 'running') ctx.resume();
            });
        }

        function doStartOscIfNeeded(idx) {
            const started = (idx === 1) ? started1 : started2;
            const osc = (idx === 1) ? osc1 : osc2;
            if (!started) {
                try {
                    osc.start();
                } catch (e) {
                    // ignore if already started
                }
                if (idx === 1) started1 = true;
                else started2 = true;
            }
        }

        function playSound(idx) {
            playingCount[idx] = Math.max(0, playingCount[idx]) + 1;
            if (stopTimeout[idx]) {
                clearTimeout(stopTimeout[idx]);
                stopTimeout[idx] = null;
            }
            if (isSounding[idx]) return;
            // phase5ではアタックを長くしてノイズ対策
            let attackTime = (phase === 5) ? 0.1 : ATTACK; // 0.1秒に変更
            osc[idx].amp(MAX_AMP, attackTime);
            isSounding[idx] = true;
            glowIntensity[idx] = 1; // グロー点灯
        }

        function stopSound(idx) {
            playingCount[idx] = Math.max(0, playingCount[idx] - 1);
            if (playingCount[idx] > 0) return;
            // phase5ではリリースをさらに短くしてクリップノイズ対策
            let releaseTime = (phase === 5) ? 0.08 : RELEASE;
            if (osc[idx]) {
                osc[idx].amp(0, releaseTime);
            }
            isSounding[idx] = false;
        }

        // マウスでの操作：メーター境界ドラッグ
        function mousePressed() {
            // ミュートボタン（20, 20, 100, 40）
            if (mouseX >= 20 && mouseX <= 120 && mouseY >= 20 && mouseY <= 60) {
                isMuted = !isMuted;
                if (isMuted) {
                    for (let i = 1; i <= 5; i++) {
                        stopSound(i);
                    }
                }
                return false;
            }
            
            // OKボタン（width/2 - 40, height - 100, 80, 40）
            if (mouseX >= width/2 - 40 && mouseX <= width/2 + 40 && 
                mouseY >= height - 100 && mouseY <= height - 60) {
                // phase1→2のみアニメーション
                if (phase >= 1 && phase <= 4) {
                    // phase遷移アニメーション用パラメータ設定
                    let from = phase;
                    let to = phase + 1;
                    let oscIdx = to;
                    // アニメ前の高さはOK押下時のfreq（オクターブ処理前）
                    let h0 = freq[oscIdx];
                    // オクターブ処理を先に適用し新しい高さを得る
                    saveAndApplyOctave(oscIdx, (to < 5) ? to + 1 : null);
                    // アニメ後の高さはオクターブ処理後のsavedFreq
                    let h1 = savedFreq[oscIdx];
                    // phase4→5だけは即座に遷移
                    if (phase === 4) {
                        freq[5] = savedFreq[5];
                        osc[5].freq(savedFreq[5]);
                        for (let i = 1; i <= 5; i++) {
                            osc[i].amp(0, 0);
                            isSounding[i] = false;
                            playingCount[i] = 0;
                        }
                        phase = 5;
                        // phase5突入時にメロディ配列・カウンタを初期化
                        // melodyPatternの値を周波数順のOSCインデックスに変換
                        let oscData = [];
                        for (let i = 1; i <= 5; i++) {
                            let oscFreq = (i === 1) ? 220 : savedFreq[i];
                            oscData.push({ idx: i, freq: oscFreq });
                        }
                        oscData.sort((a, b) => a.freq - b.freq);
                        sortedOscIndices = oscData.map(d => d.idx);
                        melody = melodyPattern.map(n => sortedOscIndices[n - 1]);
                        beatIndex = 0;
                        isRunning = true;
                        lastBeatTime = millis();
                        return false;
                    }
                    // アニメーション開始
                    phaseTransitionFrom = from;
                    phaseTransitionTo = to;
                    phaseTransitionRectH0 = h0;
                    phaseTransitionRectH1 = h1;
                    isPhaseTransitionAnimating = true;
                    phaseTransitionAnimStart = millis();
                    beatIndex = 0;
                    lastBeatTime = millis();
                    return false;
                }
                // phase5は即座に遷移
                if (phase === 5) {
                    melody = [];
                    beatIndex = 0;
                    isRunning = true;
                    lastBeatTime = millis();
                    return false;
                }
                let resetButtonW = 100;
                let resetButtonH = 40;
                if (mouseX >= resetButtonX && mouseX <= resetButtonX + resetButtonW &&
                    mouseY >= resetButtonY && mouseY <= resetButtonY + resetButtonH) {
                    // すべてのOSCを停止して phase 1にリセット
                    for (let i = 1; i <= 5; i++) {
                        stopSound(i);
                        freq[i] = 100 + i * 50;
                        osc[i].freq(freq[i]);
                    }
                    savedFreq[1] = 220;
                    osc[1].freq(220);
                    freq[1] = 220;
                    phase = 1;
                    beatIndex = 0;
                    lastBeatTime = millis();
                    return false;
                }
            }
            
            // メーター領域クリック（全フェーズ共通）
            let rect2X = width/2 + 80;
            let leftOscIdx = phase;
            let rightOscIdx = (phase === 1) ? 2 : phase + 1;
            let rectLH = savedFreq[leftOscIdx];
            let rectRH = (phase === 1) ? 440 : rectLH * 2;
            let rect2Y = height/2 + 300 - rectRH;
            let rect2W = 240;
            let rect2H = rectRH;

            if (isPhaseTransitionAnimating) return false;
            if (mouseX >= rect2X && mouseX <= rect2X + rect2W) {
                let dragBottom = rect2Y + rect2H/2;
                let dragTop = rect2Y;
                let mouseYClamped = constrain(mouseY, dragTop - 20, dragBottom + 20);
                let freqMin, freqMax, idx;
                if (phase === 1) {
                    freqMin = 220;
                    freqMax = 440;
                    idx = 2;
                } else {
                    freqMin = savedFreq[phase];
                    freqMax = savedFreq[phase] * 2;
                    idx = phase + 1;
                }
                let val = map(mouseYClamped, dragBottom, dragTop, freqMin, freqMax);
                val = constrain(val, freqMin, freqMax);
                if (mouseY >= dragTop - 20 && mouseY <= dragBottom + 20) {
                    freq[idx] = val;
                    osc[idx].freq(val);
                    isDraggingSlider = true;
                    return false;
                }
            }
        }
        function mouseDragged() {
            if (!isDraggingSlider || isPhaseTransitionAnimating) return;

            // 右の長方形の位置・サイズ
            let leftOscIdx = phase;
            let rightOscIdx = (phase === 1) ? 2 : phase + 1;
            let rectLH = savedFreq[leftOscIdx];
            let rectRH = rectLH * 2;
            let rectRY = height/2 + 300 - rectRH;
            let rectRX = width/2 + 80;
            let rectRW = 240;

            let dragBottom = rectRY + rectRH/2;
            let dragTop = rectRY;
            let mouseYClamped = constrain(mouseY, dragTop - 20, dragBottom + 20);
            let freqMin, freqMax, idx;
            if (phase === 1) {
                freqMin = 220;
                freqMax = 440;
                idx = 2;
            } else {
                freqMin = savedFreq[phase];
                freqMax = savedFreq[phase] * 2;
                idx = phase + 1;
            }
            let val = map(mouseYClamped, dragBottom, dragTop, freqMin, freqMax);
            val = constrain(val, freqMin, freqMax);
            freq[idx] = val;
            osc[idx].freq(val);
        }


        
        function mouseReleased() {
            // メーター境界ドラッグ終了
            isDraggingSlider = false;
        }

        // キーボードでの操作
        function keyPressed() {
            // 1～5キーでn番目に低い音を鳴らす
            if (['1','2','3','4','5'].includes(key)) {
                // 周波数順でOSCインデックスを取得
                let oscData = [];
                for (let i = 1; i <= 5; i++) {
                    let oscFreq = (i === 1) ? 220 : savedFreq[i];
                    oscData.push({ idx: i, freq: oscFreq });
                }
                oscData.sort((a, b) => a.freq - b.freq);
                let n = parseInt(key);
                let oscIdx = oscData[n-1].idx;
                playSound(oscIdx);
            }
        }
        function keyReleased() {
            // 1～5キーでn番目に低い音を止める
            if (['1','2','3','4','5'].includes(key)) {
                let oscData = [];
                for (let i = 1; i <= 5; i++) {
                    let oscFreq = (i === 1) ? 220 : savedFreq[i];
                    oscData.push({ idx: i, freq: oscFreq });
                }
                oscData.sort((a, b) => a.freq - b.freq);
                let n = parseInt(key);
                let oscIdx = oscData[n-1].idx;
                stopSound(oscIdx);
            }
        }
    </script>
</body>
</html>
